grammar puf.Puf;

options (backtrack=true;)

Program: Include* Rdecl+;

Include: "#" "include" file=Str; 

option Decl: Rdecl | Tdecl;
Rdecl: Flhs "=" Expr ";";
Tdecl: Tlhs "=" Expr ";";

Flhs: Id+;
Tlhs: "(" f=Id ("," r=Id)* ")";

option Expr: 
	CaseExpr 
	| LetrecExpr 
	| LetExpr 
	| FunExpr 
	| IfExpr 
	| ListLiteral
	| TupleLiteral
	| OrExpr;

CaseExpr: "case";
LetrecExpr: "letrec" Rdecl+ "in" Expr;
LetExpr: "let" Decl+ "in" Expr;
FunExpr: "fn" params=Id+ "->" Expr;
IfExpr: "if" cond=Expr "then" ifThen=Expr "else" ifElse=Expr;
ListLiteral: "[]";
TupleLiteral: "()";

OrExpr: left=AndExpr ("||" rest=AndExpr)*;
AndExpr: left=EqExpr ("&&" rest=EqExpr)*;

option EqExpr: Equals | NotEquals | CompareExpr;
Equals: left=CompareExpr "==" right=CompareExpr;
NotEquals: left=CompareExpr "/=" right=CompareExpr;

option CompareExpr:
    LessThan 
    | LessEquals
    | GreaterThan 
    | GreaterEquals 
    | ConsExpr;
LessThan: left=ConsExpr "<" right=ConsExpr;
LessEquals: left=ConsExpr "<=" right=ConsExpr;
GreaterThan: left=ConsExpr ">" right=ConsExpr;
GreaterEquals: left=ConsExpr ">=" right=ConsExpr;

ConsExpr: left=PlusExpr (":" rest=PlusExpr)*;

option PlusExpr: Plus | Minus | MulExpr;
Plus: left=MulExpr ("+" rest=MulExpr)+;
Minus: left=MulExpr ("-" rest=MulExpr)+;

option MulExpr: Mul | Div | Mod | UnaryExpr;
Mul: left=UnaryExpr ("*" rest=UnaryExpr)+;
Div: left=UnaryExpr ("/" rest=UnaryExpr)+;
Mod: left=UnaryExpr ("%" rest=UnaryExpr)+;

option UnaryExpr: NegExpr | NotExpr | SelectExpr;
NegExpr: "-" expr=PrimaryExpr;
NotExpr: "not" expr=PrimaryExpr;
// ApplyExpr: fun=PrimaryExpr param=PrimaryExpr;
SelectExpr: "#" sel=Num tuple=PrimaryExpr;

option PrimaryExpr: Id | Num | ParenExpr;
ParenExpr: "(" expr=Expr ")";

terminal Str: '"' ~('"')* '"';
terminal Id: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
terminal Num: ('0'..'9')+;
fragment MlComment: '/*' (~'*' | '*' ~'/')* '*/';
fragment SlComment: '//' ~('\n'|'\r')*;
hidden terminal Ws: (' '|'\t'|'\r'|'\n'|MlComment|SlComment)+;
